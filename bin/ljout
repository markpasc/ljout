#!/usr/bin/env python

import collections
from functools import wraps
import hashlib
from itertools import islice
import logging
import xmlrpclib

from termtool import Termtool, subcommand, argument


__version__ = '1.0'


class LJTransport(xmlrpclib.Transport):

    user_agent = "ljout/{0}".format(__version__)


class LJServerProxy(xmlrpclib.ServerProxy):

    def __init__(self, uri, username=None, password=None):
        xmlrpclib.ServerProxy.__init__(self, uri, transport=LJTransport(), allow_none=False,
            use_datetime=True)

        self._username = username
        self._password = password

    def _ServerProxy__request(self, methodname, params):
        if (params and isinstance(params[0], collections.Mapping)
            and params[0].get('auth_method') == 'challenge' and params[0].get('auth_challenge') is None):
            args = dict(params[0])
            params = (args,) + params[1:]

            chal = None
            # Try repeatedly to get a challenge, like jbackup.pl does?
            while chal is None:
                challenge_response = self.LJ.XMLRPC.getchallenge()
                chal = challenge_response.get('challenge')

            args['ver'] = 1

            args['username'] = self._username
            args['auth_challenge'] = chal
            password = hashlib.md5()
            password.update(self._password)
            response = hashlib.md5()
            response.update(chal)
            response.update(password.hexdigest())
            args['auth_response'] = response.hexdigest()

        return xmlrpclib.ServerProxy._ServerProxy__request(self, methodname, params)


_DEFAULT = object()


@argument('--site', default='www.livejournal.com')
@argument('--username')
@argument('--password')
class LJOut(Termtool):

    description = 'Export a LiveJournal.'

    def client(self, args):
        url = 'http://{0}/interface/xmlrpc'.format(args.site)
        client = LJServerProxy(url, args.username, args.password)
        return client

    @subcommand(help='set the username and password to export as')
    def configure(self, args):
        if not args.username:
            args.username = raw_input('Username: ')
        if not args.password:
            args.password = raw_input('Password: ')
        self.write_config_file(
            '--site', args.site,
            '--username', args.username,
            '--password', args.password,
        )
        print "Configured!"

    @subcommand(help='')
    @argument('--journal', help="the name of the journal to export (default: user's)")
    @argument('path', help="path to which to export the journal")
    def events(self, args):
        if args.journal is None:
            args.journal = args.username

        client = self.client(args)
        # TODO: load lastsync from exported data?
        lastsync = '0'

        event_ids = set()
        while True:
            this_lastsync = lastsync
            logging.debug("Syncing items since %r", this_lastsync)
            sync = client.LJ.XMLRPC.syncitems({
                'lastsync': this_lastsync,
                'usejournal': args.journal,
                'auth_method': 'challenge',
            })

            for item in sync['syncitems']:
                item_code, item_id = item['item'].split('-', 1)
                item_id = int(item_id)
                if item_code == 'L':
                    event_ids.add(item_id)
                if item['time'] > lastsync:
                    lastsync = item['time']

            if event_ids:
                logging.debug("Getting events since %r", this_lastsync)
                events = client.LJ.XMLRPC.getevents({
                    'auth_method': 'challenge',
                    'usejournal': args.journal,
                    'selecttype': 'syncitems',
                    'lastsync': this_lastsync,
                    'lineendings': 'unix',
                })

                for event in events['events']:
                    item_id = event['itemid']
                    logging.debug('Have syncitem %r?', item_id)
                    event_ids.remove(item_id)  # must exist

                    self.export_event(event, args)

            if event_ids:
                logging.debug('Oops, there are syncitems left over :E')
                raise ValueError("AIEE DIDN'T SEE UPDATE FOR %d EVENTS INCLUDING #%r :E"
                    % (len(event_ids), iter(event_ids).next()))

            # TODO: don't quit anyway (but do for now while debugging)
            break
            # Did we finish?
            if sync['count'] == sync['total']:
                break

        logging.debug("Exported events!")

    def export_event(self, event, args):
        pass


if __name__ == '__main__':
    LJOut().run()
